\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[WWW'17]{The ACM 26th International World Wide Web 
conference}{April 2017}{Perth, Australia} 
\acmYear{2017}
\copyrightyear{2017}

%\acmPrice{15.00}

\input{defines}

\begin{document}
\title{AncestryAI: a tool for exploring computationally \\ inferred family 
trees}
%\titlenote{Produces the permission block, and
%  copyright information}
%\subtitle{Extended Abstract}
%\subtitlenote{The full version of the author's guide is available as
%  \texttt{acmart.pdf} document}


\author{Eric Malmi}
%\authornote{Dr.~Trovato insisted his name be first.}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Aalto University}
  \city{Espoo}
  \country{Finland}
}
\email{eric.malmi@aalto.fi}

\author{Marko Rasa}
\authornote{The majority of this work was completed while the author was a 
research assistant in Aalto University.}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Verto Analytics}
  \city{Espoo}
  \country{Finland}
}
\email{marko.rasa@vertoanalytics.com}

\author{Aristides Gionis}
%\authornote{Dr.~Trovato insisted his name be first.}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Aalto University}
  \city{Espoo}
  \country{Finland}
}
\email{aristides.gionis@aalto.fi}

% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et. al.}


\begin{abstract}
Foo bar.
\end{abstract}

\iffalse
%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}
\fi

% We no longer use \terms command
%\terms{Theory}

\keywords{family trees, genealogy, probabilistic modeling, graph drawing}


\maketitle

\section{Introduction}

\section{Main features}

\begin{itemize}
 \item Alternative parents ranked by likelihood (easy to navigate through 
 clicking)
 \item Search by relative
 \item Path search
 \item Annotation
\end{itemize}

\section{Probabilistic family tree inference}

Family trees can be inferred by matching the birth records of children to the 
birth records of their parents. Each birth record typically contains at least 
the name, birth place, and birth date of the child in addition to the names of 
the parents. All of these fields are useful for inferring the most likely birth 
records of the parents. Next we derive a formula for matching probability, 
discuss computational issues related to evaluating the probability formula, and 
discuss the estimation of the different terms in the formula.

\subsection{Matching probability}

Let \M be a discrete random variable indicating the birth record belonging to 
one of the parents mentioned in the birth record at hand. We want to estimate 
the matching probabilities over $n$ candidate birth records of the parent, in 
addition to the case that the matching record is missing denoted by $M=n+1$. 
The probabilities are estimated based on comparison vectors $\comps = 
\left[\comp{1}, \dots, \comp{n}\right]$ corresponding to the similarity values 
of the candidate record fields and the fields of the record to be matched.

First note that the likelihood of the comparison vectors can be written as
\begin{align}
 \p{\comps \mid M=i} &= \prod_{k=1}^{n} \p{\comp{k} \mid M=i} \nonumber \\
 &= \frac{\p{\comp{i} \mid M=i} \prod_{k=1}^{n} \p{\comp{k} \mid M\neq 
 k}}{\p{\comp{i} \mid M\neq i}} \nonumber \\
 &= C \frac{\p{\comp{i} \mid M=i}}{\p{\comp{i} \mid M\neq i}}, \nonumber
\end{align}
where the product term $C$ is constant with respect to $i$ and where 
$\p{\comp{i} \mid M=i}$ is the likelihood of observing the comparison 
vector \comp{i} when $i$ is the matching record and $\p{\comp{i} \mid M\neq i}$ 
when it is not.
Now the matching probability is given by
\begin{align}
 & \p{\M = i \mid \comps} \nonumber \\
 &\quad = \frac{\p{M=i}\p{\comps \mid M=i} }{ \sum_{j=1}^{n+1} 
 \p{M=j} \p{\comps \mid M=j}} \nonumber \\
 &\quad = \frac{\p{M=i}\p{\comp{i} \mid M=i} \bigm/ \p{\comp{i} \mid 
 M\neq i}}{\sum_{j=1}^{n+1} \p{M=j} \p{\comp{j} \mid M=j} \bigm/ \p{\comp{j} 
 \mid M\neq j}}, \label{eq:prob}
\end{align}
where $\p{\comp{n+1} \mid M=n+1} \bigm/ \p{\comp{n+1} \mid M\neq n+1}$ is 
defined to be 1.
It is common to assume that the record fields are conditionally independent 
\cite{christen2012} which allows us to write $\p{\comp{j} \mid M=k} = 
\prod_i \p{\com{j}{i} \mid M=j}$, where the product is over the different 
fields, that is, name, birth place, and birth date in our case. The estimation 
of these likelihood terms along with the prior probabilities are discussed in 
Section~\ref{sec:estimation}.

Note that (\ref{eq:prob}) is related to the famous Fellegi--Sunter 
model \cite{fellegi1969} which ranks record pairs based on their likelihood 
ratios, but here we additionally weight the ratios by the prior probability 
$\p{M=i}$ and normalize them to get probabilities. 

\subsection{Computational issues}

Comparing every pair of records would lead to a quadratic running time which 
may not be feasible when the number of records is in millions. Therefore, it is 
common to employ \emph{blocking} (or \emph{indexing}) which can significantly 
reduce the number of record comparisons \cite{christen2012} by pulling only 
record pairs with a nonzero match probability from an inverted index.

For birth record matching, the birth date is a natural blocking criteria. We 
can relatively safely discard all record pairs where the candidate parent is 
less than 10 years older or more than 70 years older than the 
child.\footnote{Due to errors in the recorded birth dates, this blocking 
criteria may, however, remove some of the matching pairs.} Additionally, we can 
limit to record pairs where the two names have the same Soundex code and 
therefore sound similar.

\subsection{Estimating probability distributions from data}
\label{sec:estimation}

To estimate the terms of (\ref{eq:prob}), we rely on training data with known 
matches. The prior probability of a missing match $\p{M=n+1}$ can be estimated 
based on the fraction training records for which the golden match is not found 
among the candidate records after the blocking step.

To compute the comparison vector \comps, we need to define a similarity measure 
for each record field.
For name comparisons, we use the average of the Jaro--Winkler string similarity 
of the first names and last names since Jaro--Winkler is a popular choice for 
de-duplicating name records \cite{winkler1990}. For birth place comparisons, we 
can use the distance between their coordinates which are estimated using 
\cite{malmi2015}. Finally, for birth year comparisons, we can simply use the 
difference between the birth years.

The likelihood terms $\p{\com{j}{i} \mid M=j}$ can be computed based on the 
distributions of the similarity measure values of field $i$ among the known 
matches. Some of the birth records contain the age of the mother so for that 
particular term, the known matches are not needed. The likelihood distribution 
for the age of the mother is shown in Figure \note{Add figure here.}.

For the likelihoods of the non-matching pairs $\p{\com{j}{i} \mid M\neq j}$ 
golden matches are not needed. These distributions can be computed based on the 
similarity measures among all candidate matches for a sample of birth records. 
Furthermore, to get refined probability estimates, the non-matching 
distributions can be conditioned by the value of the field to be matched, for 
example, by the popularity of the name since if there is a rare name, it 
provides a stronger signal in the case that a match is found since this is 
unlikely to happen by chance.

\section{Family tree layout algorithm}

Complex since family trees are not trees but DAGs.

\section{Discussion}

Future work
\begin{itemize}
 \item More formal analysis of the layout algorithm and comparison to DAG 
 drawing techniques.
 \item More sophisticated family tree inference method which does not match the 
 records independently and which leverages marriage and burial records.
 \item Collection of training and evaluation data once the demo has been 
 running for awhile.
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc} 

\end{document}
